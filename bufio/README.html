<!DOCTYPE HTML>
<html lang="en-US" manifest="../manifest.appcache">
    
    <head>
        
        <meta charset="UTF-8">
        <title>bufio | </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 0.7.1">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    <meta name="author" content="goManual">
    
    
    
    <link rel="prev" href="../archive/zip.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book" data-github="goManual/goManual" data-level="2" data-basepath=".." data-revision="1408456557227">
    <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    
    <a href="https://github.com/goManual/goManual" target="_blank" class="btn pull-left home-bookmark" aria-label="GitHub home"><i class="fa fa-bookmark-o"></i></a>
    
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    <span id="font-settings-wrapper">
        <a href="#" class="btn pull-left toggle-font-settings" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="btn-group btn-block">
        <button id="reduce-font-size" class="btn btn-default">A</button>
        <button id="enlarge-font-size" class="btn btn-default">A</button>
    </div>

    <ul class="list-group font-family-list">
        <li class="list-group-item" data-font="0">Serif</li>
        <li class="list-group-item" data-font="1">Sans</li>
    </ul>

    <div class="btn-group btn-group-xs btn-block color-theme-list">
        <button type="button" class="btn btn-default" id="color-theme-preview-0" data-theme="0">White</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-1" data-theme="1">Sepia</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-2" data-theme="2">Night</button>
    </div>
</div>

    </span>

    <!-- Actions Right -->
    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-spinner fa-spin"></i>
        <a href="../" ></a>
    </h1>
</div>

    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        
        
        <li>
            <a href="https://github.com/goManual" target="blank" class="author-link">About the author</a>
        </li>
        

        
        
        <li>
            <a href="https://github.com/goManual/goManual/issues" target="blank" class="issues-link">Questions and Issues</a>
        </li>
        

        
        
        <li>
            <a href="https://github.com/goManual/goManual/edit/master/bufio/README.md" target="blank" class="contribute-link">Edit and Contribute</a>
        </li>
        

	

        
        <li class="divider"></li>
        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         简介
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="archive/README.html">
            
                
                    <a href="../archive/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         archive
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="archive/tar.html">
            
                
                    <a href="../archive/tar.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         tar
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.2" data-path="archive/zip.html">
            
                
                    <a href="../archive/zip.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         zip
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter active" data-level="2" data-path="bufio/README.html">
            
                
                    <a href="../bufio/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         bufio
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Generated using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 100%;min-width: 75%;"></div>
    </div>
    <div class="chapters">
    
        <a href="../index.html" title="简介" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="../archive/README.html" title="archive" class="chapter done new-chapter" data-progress="1" style="left: 25%;"></a>
    
        <a href="../archive/tar.html" title="tar" class="chapter done " data-progress="1.1" style="left: 50%;"></a>
    
        <a href="../archive/zip.html" title="zip" class="chapter done " data-progress="1.2" style="left: 75%;"></a>
    
        <a href="../bufio/README.html" title="bufio" class="chapter done new-chapter" data-progress="2" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_5">
                    
                        <h1 id="package-bufio">Package bufio</h1>
<h3 id="overview">Overview</h3>
<p>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.<br>
bufio包实现缓冲区I/O。它包装一个io.Reader或io.Writer对象，创建其他对象 (Reader or Writer) 也实现了该接口 并为I/O文本提供缓冲和一些帮助。<br>
<br><br></p>
<h3 id="constants">Constants</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">const</span> (
    <span class="hljs-comment">// Maximum size used to buffer a token. The actual maximum token size</span>
    <span class="hljs-comment">// may be smaller as the buffer may need to include, for instance, a newline.</span>
    MaxScanTokenSize =<span class="hljs-number"> 64</span> *<span class="hljs-number"> 1024</span>
)
</code></pre>
<p><br><br></p>
<h3 id="variables">Variables</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">var</span> (
    ErrInvalidUnreadByte = errors.New(<span class="hljs-string">"bufio: invalid use of UnreadByte"</span>)
    ErrInvalidUnreadRune = errors.New(<span class="hljs-string">"bufio: invalid use of UnreadRune"</span>)
    ErrBufferFull        = errors.New(<span class="hljs-string">"bufio: buffer full"</span>)
    ErrNegativeCount     = errors.New(<span class="hljs-string">"bufio: negative count"</span>)
)
</code></pre>
<pre><code class="lang-golang"><span class="hljs-keyword">var</span> (
    ErrTooLong         = errors.New(<span class="hljs-string">"bufio.Scanner: token too long"</span>)
    ErrNegativeAdvance = errors.New(<span class="hljs-string">"bufio.Scanner: SplitFunc returns negative advance count"</span>)
    ErrAdvanceTooFar   = errors.New(<span class="hljs-string">"bufio.Scanner: SplitFunc returns advance count beyond input"</span>)
)
</code></pre>
<p>Errors returned by Scanner.<br>
错误通过Scanner返回.<br>
<br><br></p>
<h3 id="func-scanbytes">func ScanBytes</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanBytes(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanBytes is a split function for a Scanner that returns each byte as a token.<br>
ScanBytes是一个分割函数，返回每个字节作为一个token.<br>
<br><br></p>
<h3 id="func-scanlines">func ScanLines</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanLines(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker.The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline.In regular expression notation, it is <code>\r?\n</code>. The last non-empty line of input will be returned even if it has no newline.<br>
ScanLines是一个分割函数。返回文本的每一行，消除任何行尾标记。返回的行有可能是空的. 行尾标记是可选回车强制性的跟在换行符之后。在正则表达式里,它是 <code>\r?\n</code>.最后的非空输入行将会返回 即使它没有换行符.<br>
<br><br></p>
<h3 id="func-scanrunes">func ScanRunes</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanRunes(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token.The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = &quot;\xef\xbf\xbd&quot;.Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.<br>
ScanRunes是一个分割函数, 返回每个 UTF-8编码rune作为 token.rune返回的顺序相当于从一系列循环遍历输入一个字符串，其中错误的utf8，会转为 U+FFFD= &quot;\xef\xbf\xbd&quot;.因为Scan接口，可能让客户端从错误编码中分辨正确的编码 来替换runes.<br>
<br><br></p>
<h3 id="func-scanwords">func ScanWords</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanWords(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanWords is a split function for a Scanner that returns each space-separated word of text , with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.<br>
ScanWords是一个分割函数,返回每个空格分隔的文本的词,会删除两边的空格. 它不会返回空字符串. 空格由unicode.IsSpace定义.<br>
<br><br></p>
<h3 id="type-readwriter">type ReadWriter</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">struct</span> {
        *Reader
        *Writer
  }
</code></pre>
<p>ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.<br>
ReadWriter存储一个Reader 和 Writer 指针，实现了io.ReadWriter.<br>
<br><br></p>
<h3 id="func-newreadwriter">func NewReadWriter</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> NewReadWriter(r *Reader, w *Writer) *ReadWriter
</code></pre>
<p>NewReadWriter allocates a new ReadWriter that dispatches to r and w.<br>
NewReadWriter分配一个新的ReadWriter ,分派r和w.<br>
<br><br></p>
<h3 id="type-reader">type Reader</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// contains filtered or unexported fields</span>
}
</code></pre>
<p>Reader implements buffering for an io.Reader object.<br>
Reader实现io.Reader对象的缓冲。<br>
<br><br></p>
<p>func NewReader</p>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> NewReader(rd io.Reader) *Reader
</code></pre>
<p>NewReader returns a new Reader whose buffer has the default size.<br>
NewReader 返回一个新的有默认缓冲区大小的Reader.<br>
<br><br></p>
<h3 id="func-newreadersize">func NewReaderSize</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> NewReaderSize(rd io.Reader, size <span class="hljs-typename">int</span>) *Reader
</code></pre>
<p>NewReaderSize returns a new Reader whose buffer has at least the specified size . If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.<br>
NewReaderSize返回一个新的最少有指定size大小的Reader，如果参数io.Reader是一个足够大的Reader，它返回底层Reader.<br>
<br><br></p>
<h3 id="func-reader-buffered">func (*Reader) Buffered</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) Buffered() <span class="hljs-typename">int</span>
</code></pre>
<p>Buffered returns the number of bytes that can be read from the current buffer.<br>
Buffered返回当前缓冲区可读的字节数.<br>
<br><br></p>
<h3 id="func-reader-peek">func (*Reader) Peek</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) Peek(n <span class="hljs-typename">int</span>) ([]<span class="hljs-typename">byte</span>, error)
</code></pre>
<p>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call.If Peek returns fewer than n bytes, it also returns an error explaining why the read is short.The error is ErrBufferFull if n is larger than b&#39;s buffer size.<br>
Peek 返回下n个字节 没有推进reader. 该字节直到下一次读取调用之前都是有效的.如果Peek 返回少于n字节,它也会返回错误解释为什么读取短了.如果n大于 b的缓冲区大小,那错误是ErrBufferFull.<br>
<br><br></p>
<h3 id="func-reader-read">func (*Reader) Read</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) Read(p []<span class="hljs-typename">byte</span>) (n <span class="hljs-typename">int</span>, err error)
</code></pre>
<p>Read reads data into p. It returns the number of bytes read into p. It calls Read at most once on the underlying Reader, hence n may be less than len(p). At EOF, the count will be zero and err will be io.EOF.<br>
Read读取数据到P. 返回读取到P的字节数.在底层Reader它最多调用一次Read,因此n 可能少于 len(p).在EOF,统计将是零并且err是io.EOF.<br>
<br><br></p>
<h3 id="unc-reader-readbyte">unc (*Reader) ReadByte</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) ReadByte() (c <span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ReadByte reads and returns a single byte. If no byte is available, returns an error.<br>
ReadByte读取和返回单个字节.如果没有可用字节,返回错误.<br>
<br><br></p>
<h3 id="func-reader-readbytes">func (*Reader) ReadBytes</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadBytes(delim <span class="hljs-typename">byte</span>) (line []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.<br>
ReadBytes读取输入的字节，直到第一次遇到delim，返回包含数据和那个分隔符的切片. 如果ReadBytes在发现分隔符之前出现错误，它返回错误之前读取的数据和错误本身(错误经常是io.EOF). ReadBytes只有在数据没有遇到分隔符但却已经读到结束的时候会返回err!=nil。对于简单的运用，Scanner 可能更适合.<br>
<br><br></p>
<h3 id="func-reader-readline">func (*Reader) ReadLine</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadLine() (line []<span class="hljs-typename">byte</span>, isPrefix <span class="hljs-typename">bool</span>, err error)
    ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes(<span class="hljs-string">'\n'</span>) or ReadString(<span class="hljs-string">'\n'</span>) instead or use a Scanner.
        ReadLine是一个低级的行读取方式。更多的会使用ReadBytes(<span class="hljs-string">'\n'</span>)或者 ReadString(<span class="hljs-string">'\n'</span>) 替代 或者用Scanner
    ReadLine tries to <span class="hljs-keyword">return</span> a single line, not including the end-of-line bytes. If the line was too long <span class="hljs-keyword">for</span> the buffer then isPrefix is set and the beginning of the line is returned.
        ReadLine试图返回单行，不包含结束字节。如果缓冲区的行太长，isPrefix 设置返回行的开始。
     The rest of the line will be returned from future calls. isPrefix will be <span class="hljs-constant">false</span> when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine.
         其余的行将会在调用的时候返回。isPrefix 在返回完所有的行后，会变成<span class="hljs-constant">false</span>。返回的缓冲区在下次调用ReadLine之前是有效的。
     ReadLine either returns a non-<span class="hljs-constant">nil</span> line or it returns an error, never both.
        ReadLine 要嘛返回非空的行要嘛返回错误，不会两个都同时返回
    The text returned from ReadLine does not include the line end (<span class="hljs-string">"\r\n"</span> or <span class="hljs-string">"\n"</span>). No indication or error is given <span class="hljs-keyword">if</span> the input ends without a final line end.
        ReadLine 返回的文本不包含行结束的 (<span class="hljs-string">"\r\n"</span> or <span class="hljs-string">"\n"</span>)。在最后一行结束之前是不会有任何迹象和错误的
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadRune() (r <span class="hljs-typename">rune</span>, size <span class="hljs-typename">int</span>, err error)
    ReadRune reads  single UTF<span class="hljs-number">-8</span> encoded Unicode character and returns the <span class="hljs-typename">rune</span> and its size in bytes.
    If the encoded <span class="hljs-typename">rune</span> is invalid, it consumes one <span class="hljs-typename">byte</span> and returns unicode.ReplacementChar (U+FFFD) with a size of<span class="hljs-number"> 1</span>.
    ReadRune 读取单个utf8 格式的字符返回<span class="hljs-typename">rune</span>和<span class="hljs-typename">rune</span>的size。
     如果<span class="hljs-typename">rune</span>编码无效，它会消耗一个字节 返回unicode.ReplacementChar(U+FFFD)<span class="hljs-number">的1</span>个大小
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadSlice(delim <span class="hljs-typename">byte</span>) (line []<span class="hljs-typename">byte</span>, err error)
    ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer.
    The bytes stop being valid at the next read call. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF).
    ReadSlice fails with error ErrBufferFull <span class="hljs-keyword">if</span> the buffer fills without a delim.
    Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead.
    ReadSlice returns err != <span class="hljs-constant">nil</span> <span class="hljs-keyword">if</span> and only <span class="hljs-keyword">if</span> line does not end in delim.
     读取直到遇到分隔符delim，返回一个指向字节的缓冲区切片。
     下一次调用后失效。如果ReadSlice在遇到分隔符之前发生错误，将会返回缓冲区里的所有数据和错误，如果缓冲区满了，但是还没遇到分隔符就会有 ErrBufferFull的错误。
     因为ReadSlice 返回的数据会覆盖下一个IO操作，所以大部分的客户端用 ReadBytes 或 ReadString 替代。
    ReadSlice 只会在行没有分隔符结束的情况下返回err != <span class="hljs-constant">nil</span>
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadString(delim <span class="hljs-typename">byte</span>) (line <span class="hljs-typename">string</span>, err error)
    ReadString reads until the first occurrence of delim in the input, returning a <span class="hljs-typename">string</span> containing the data up to and including the delimiter.
    If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF).
    ReadString returns err != <span class="hljs-constant">nil</span> <span class="hljs-keyword">if</span> and only <span class="hljs-keyword">if</span> the returned data does not end in delim. For simple uses, a Scanner may be more convenient.
    ReadString读取直接遇到第一个分隔符。返回包含分隔符的字符串。
     如果ReadString在没有发现分隔符就遇到错误，返回发生错误之前读取的数据和错误。
    ReadString 只会在行没有分隔符结束的情况下返回err != <span class="hljs-constant">nil</span>。对于简单的运用，Scanner 更方便
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) UnreadByte() error
    UnreadByte unreads the last <span class="hljs-typename">byte</span>. Only the most recently read <span class="hljs-typename">byte</span> can be unread.
     撤销最后一次读书的字节。只有最后读的字节可以被撤销
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) UnreadRune() error
    UnreadRune unreads the last <span class="hljs-typename">rune</span>. If the most recent read operation on the buffer was not a ReadRune, UnreadRune returns an error.
     撤销最后一次读出的<span class="hljs-typename">rune</span>.如果最后一次操作不是ReadRune，返回错误。
    (In this regard it is stricter than UnreadByte, which will unread the last <span class="hljs-typename">byte</span> from any read operation.)
    （在这方面，它比UnreadByte严格）
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) WriteTo(w io.Writer) (n <span class="hljs-typename">int64</span>, err error)
    WriteTo implements io.WriterTo.
     实现io.WriterTo
</code></pre>
<pre><code class="lang-golang"><span class="hljs-keyword">type</span> Scanner
  <span class="hljs-keyword">type</span> Scanner <span class="hljs-keyword">struct</span> {
        <span class="hljs-comment">// contains filtered or unexported fields</span>
  }
  Scanner provides a convenient <span class="hljs-keyword">interface</span> <span class="hljs-keyword">for</span> reading data such as a file of newline-delimited lines of text.
      Scanner提供一个更方便的接口读取数据，像文件的新行分隔文本的行。
  Successive calls to the Scan method will step through the <span class="hljs-string">'tokens'</span> of a file, skipping the bytes between the tokens.
      继承Scan方法的使用tokens对文件单步调试调用，跳出标记之间的字节。
  The specification of a token is defined by a split function of <span class="hljs-keyword">type</span> SplitFunc; the <span class="hljs-keyword">default</span> split function breaks the input into lines with line termination stripped.
      token是一个SplitFunc类型的分割函数，默认的分割函数将输入的行中断。
  Split functions are defined in this <span class="hljs-keyword">package</span> <span class="hljs-keyword">for</span> scanning a file into lines, bytes, UTF<span class="hljs-number">-8</span>-encoded runes, and space-delimited words. The client may instead provide a custom split function.
      分割函数在这个包的是一个文件的行，字节，UTF8字节和间隔符。客户端可以自定义函数来替代分割函数。
  Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token.
      搜索在遇到结束符、第一个I/O错误、或者token大于缓冲区的大小。当一个搜索结束，读取者也许会离最后一个token任意远。
  Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead.
      程序在必须更多的控制错误处理或太大的tokens，或者连续的搜索，应该用 bufio.Reader代替
</code></pre>
<p>Example (Custom)
Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.
Code:</p>
<pre><code class="lang-golang"><span class="hljs-comment">// An artificial input source.</span>
<span class="hljs-keyword">const</span> input = <span class="hljs-string">"1234 5678 1234567901234567890"</span>
scanner := bufio.NewScanner(strings.NewReader(input))
<span class="hljs-comment">// Create a custom split function by wrapping the existing ScanWords function.</span>
split := <span class="hljs-keyword">func</span>(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error) {
    advance, token, err = bufio.ScanWords(data, atEOF)
    <span class="hljs-keyword">if</span> err == <span class="hljs-constant">nil</span> &amp;&amp; token != <span class="hljs-constant">nil</span> {
        _, err = strconv.ParseInt(<span class="hljs-typename">string</span>(token),<span class="hljs-number"> 10</span>,<span class="hljs-number"> 32</span>)
    }
    <span class="hljs-keyword">return</span>
}
<span class="hljs-comment">// Set the split function for the scanning operation.</span>
scanner.Split(split)
<span class="hljs-comment">// Validate the input</span>
<span class="hljs-keyword">for</span> scanner.Scan() {
    fmt.Printf(<span class="hljs-string">"%s\n"</span>, scanner.Text())
}

<span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-constant">nil</span> {
    fmt.Printf(<span class="hljs-string">"Invalid input: %s"</span>, err)
}
</code></pre>
<p>Output:</p>
<pre><code class="lang-golang"><span class="hljs-number">1234</span><span class="hljs-number">
5678</span>
Invalid input: strconv.ParseInt: parsing <span class="hljs-string">"1234567901234567890"</span>: value out of <span class="hljs-keyword">range</span>
</code></pre>
<pre><code class="lang-golang">Example (Lines)
The simplest use of a Scanner, to read standard input as a set of lines.

Code:

scanner := bufio.NewScanner(os.Stdin)
<span class="hljs-keyword">for</span> scanner.Scan() {
    fmt.Println(scanner.Text()) <span class="hljs-comment">// Println will add back the final '\n'</span>
}
<span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-constant">nil</span> {
    fmt.Fprintln(os.Stderr, <span class="hljs-string">"reading standard input:"</span>, err)
}
</code></pre>
<p>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.
Code:</p>
<pre><code class="lang-golang"><span class="hljs-comment">// An artificial input source.</span>
<span class="hljs-keyword">const</span> input = <span class="hljs-string">"Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n"</span>
scanner := bufio.NewScanner(strings.NewReader(input))
<span class="hljs-comment">// Set the split function for the scanning operation.</span>
scanner.Split(bufio.ScanWords)
<span class="hljs-comment">// Count the words.</span>
count :=<span class="hljs-number"> 0</span>
<span class="hljs-keyword">for</span> scanner.Scan() {
    count++
}
<span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-constant">nil</span> {
    fmt.Fprintln(os.Stderr, <span class="hljs-string">"reading input:"</span>, err)
}
fmt.Printf(<span class="hljs-string">"%d\n"</span>, count)
</code></pre>
<p>Output:</p>
<pre><code class="lang-golang"><span class="hljs-number">15</span>
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> NewScanner(r io.Reader) *Scanner
    NewScanner returns a <span class="hljs-built_in">new</span> Scanner to read from r. The split function defaults to ScanLines
    NewScanner 从r返回一个新的*Scanner。分割函数默认是ScanLines
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Bytes() []<span class="hljs-typename">byte</span>
    Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.
    Bytes 将最后一次扫描出的切片返回。调用Scan 会覆盖 底层数组指向的数据。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Err() error
    Err returns the first non-EOF error that was encountered by the Scanner.
    Err 在Scanner遇到第一个非EOF错误返回
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Scan() <span class="hljs-typename">bool</span>
    Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method.
    It returns <span class="hljs-constant">false</span> when the scan stops, either by reaching the end of the input or an error.
    After Scan returns <span class="hljs-constant">false</span>, the Err method will <span class="hljs-keyword">return</span> any error that occurred during scanning, except that <span class="hljs-keyword">if</span> it was io.EOF, Err will <span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>.
    Scan 搜索下一个标记， 然后通过Bytes或者Text方法取出。
    当然搜索停止、搜索到末尾、或遇到错误时返回<span class="hljs-constant">false</span>。
    当Scan 返回<span class="hljs-constant">false</span>。Err 方法将会返回在搜索期间遇到的任何错误，除了io.EOF会返回<span class="hljs-constant">nil</span>。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Split(split SplitFunc)
    Split sets the split function <span class="hljs-keyword">for</span> the Scanner. If called, it must be called before Scan. The <span class="hljs-keyword">default</span> split function is ScanLines.
    Split 设置搜索的分割函数，如果有调用，必须在Scan之前调用，默认的分割函数是ScanLines
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Text() <span class="hljs-typename">string</span>
    Text returns the most recent token generated by a call to Scan as a newly allocated <span class="hljs-typename">string</span> holding its bytes.
    Text 返回在调用Scan重新分配字符串的时候,最后一次扫描的字符串
</code></pre>
<pre><code class="lang-golang"><span class="hljs-keyword">type</span> SplitFunc
  <span class="hljs-keyword">type</span> SplitFunc <span class="hljs-keyword">func</span>(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
    SplitFunc is the signature of the split function used to tokenize the input.
    The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give.
    The <span class="hljs-keyword">return</span> values are the number of bytes to advance the input and the next token to <span class="hljs-keyword">return</span> to the user, plus an error, <span class="hljs-keyword">if</span> any.
    If the data does not yet hold a complete token, <span class="hljs-keyword">for</span> instance <span class="hljs-keyword">if</span> it has no newline while scanning lines,
    SplitFunc can <span class="hljs-keyword">return</span> <span class="hljs-number">(0</span>, <span class="hljs-constant">nil</span>) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input.

    SplitFunc是分割函数用于标记输入。参数是Reader有没有更多的数据时的一个未处理的字串和一个atEOF标示
     返回值是读取到下一个标示的字节数，如果有错误的话加上一个错误。
     如果数据没有一个完整的标示，例如扫描行的时候没有新行，
    SplitFunc <span class="hljs-keyword">return</span> <span class="hljs-number">(0</span>, <span class="hljs-constant">nil</span>)的标示，Scanner 在输入的时候尝试用一个更长的切片的同一个指针开始 ， 从切片中读取更多的数据

    If the returned error is non-<span class="hljs-constant">nil</span>, scanning stops and the error is returned to the client.
     如果返回的错误不是<span class="hljs-constant">nil</span>，扫描终止，错误返回给客户端。
    The function is never called with an empty data slice unless atEOF is <span class="hljs-constant">true</span>. If atEOF is <span class="hljs-constant">true</span>, however, data may be non-empty and, as always, holds unprocessed text.
     除非atEOF 参数的值是<span class="hljs-constant">true</span>，否则函数不会调用一个空数据的切片。如果atEOF 是<span class="hljs-constant">true</span>，data参数有可能是非空的，通常是未处理的数据
</code></pre>
<pre><code class="lang-golang"><span class="hljs-keyword">type</span> Writer
  Writer implements buffering <span class="hljs-keyword">for</span> an io.Writer object. If an error occurs writing to a Writer, no more data will be accepted and all subsequent writes will <span class="hljs-keyword">return</span> the error.
  Writer实现 io.Writer 缓冲区对象。如果遇到错误，就不会再写入数据，并且后面的写入都会返回错误。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> NewWriter(wr io.Writer) *Writer
    NewWriter returns a <span class="hljs-built_in">new</span> Writer whose buffer has the <span class="hljs-keyword">default</span> size.
    NewWriter 返回一个有默认大小的缓冲区Writer
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> NewWriterSize(wr io.Writer, size <span class="hljs-typename">int</span>) *Writer
    NewWriterSize returns a <span class="hljs-built_in">new</span> Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.
    NewWriterSize 返回一个至少有指定大小的缓冲区新对象。如果参数io.Writer是一个足够大小的Writer，会返回Writer。 （注：就是说谁大返回谁）
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Available() <span class="hljs-typename">int</span>
    Available returns how many bytes are unused in the buffer.
    Available 返回缓冲区还有多少字节没有被使用。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Buffered() <span class="hljs-typename">int</span>
    Buffered returns the number of bytes that have been written into the current buffer.
    Buffered 返回已经被写入的缓冲区的字节数。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Flush() error
    Flush writes any buffered data to the underlying io.Writer.
    Flush 把缓冲区数据写入到底层io.Writer
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) ReadFrom(r io.Reader) (n <span class="hljs-typename">int64</span>, err error)
    ReadFrom implements io.ReaderFrom.
    ReadFrom 实现 io.ReaderFrom.
</code></pre>
<pre><code class="lang-golang">    <span class="hljs-keyword">func</span> (b *Writer) Reset(w io.Writer)
        Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.
        丢弃缓冲区里未刷新的数据，清除所有错误，重置b写入到w
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Write(p []<span class="hljs-typename">byte</span>) (nn <span class="hljs-typename">int</span>, err error)
    Write writes the contents of p into the buffer. It returns the number of bytes written. If nn &lt; <span class="hljs-built_in">len</span>(p), it also returns an error explaining why the write is short.
    Write将p的内容写入缓冲区。返回写入字节数。如果返回的字节数nn 小于 p的长度，它也会返回一个错误说明为什么写入短了。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) WriteByte(c <span class="hljs-typename">byte</span>) error
    WriteByte writes a single <span class="hljs-typename">byte</span>.
    WriteByte写入单字节
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) WriteRune(r <span class="hljs-typename">rune</span>) (size <span class="hljs-typename">int</span>, err error)
    WriteRune writes a single Unicode code point, returning the number of bytes written and any error.
    WriteRune写入单个Unicode编码字符。返回写入的字节数并返回遇到的错误。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) WriteString(s <span class="hljs-typename">string</span>) (<span class="hljs-typename">int</span>, error)
    WriteString writes a <span class="hljs-typename">string</span>. It returns the number of bytes written. If the count is less than <span class="hljs-built_in">len</span>(s), it also returns an error explaining why the write is short.
    WriteString 写入一个字符串。返回写入的字节数。如果字节数少于s参数的长度，它也会返回一个错误说明为什么写入短了。
</code></pre>

                    
                    </section>
                
                </div>
            </div>
        </div>

<!--
        
        <a href="../archive/zip.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: zip"><i class="fa fa-angle-left"></i></a>
        
        
-->

    </div>
</div>

        
<script src="../gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
<script src="../gitbook/app.js"></script>

<script src="../gitbook/MathJax.js"></script>
<!--
    
    <script src="https://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    
-->


<script>
require(["gitbook"], function(gitbook) {
    var config = {};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
