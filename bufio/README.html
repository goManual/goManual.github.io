<!DOCTYPE HTML>
<html lang="en-US" manifest="../manifest.appcache">
    
    <head>
        
        <meta charset="UTF-8">
        <title>bufio | </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 0.7.1">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    <meta name="author" content="goManual">
    
    
    <link rel="next" href="../builtin/README.html" />
    
    
    <link rel="prev" href="../archive/zip.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book" data-github="goManual/goManual" data-level="2" data-basepath=".." data-revision="1408542540390">
    <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    
    <a href="https://github.com/goManual/goManual" target="_blank" class="btn pull-left home-bookmark" aria-label="GitHub home"><i class="fa fa-bookmark-o"></i></a>
    
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    <span id="font-settings-wrapper">
        <a href="#" class="btn pull-left toggle-font-settings" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="btn-group btn-block">
        <button id="reduce-font-size" class="btn btn-default">A</button>
        <button id="enlarge-font-size" class="btn btn-default">A</button>
    </div>

    <ul class="list-group font-family-list">
        <li class="list-group-item" data-font="0">Serif</li>
        <li class="list-group-item" data-font="1">Sans</li>
    </ul>

    <div class="btn-group btn-group-xs btn-block color-theme-list">
        <button type="button" class="btn btn-default" id="color-theme-preview-0" data-theme="0">White</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-1" data-theme="1">Sepia</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-2" data-theme="2">Night</button>
    </div>
</div>

    </span>

    <!-- Actions Right -->
    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-spinner fa-spin"></i>
        <a href="../" ></a>
    </h1>
</div>

    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        
        
        <li>
            <a href="https://github.com/goManual" target="blank" class="author-link">About the author</a>
        </li>
        

        
        
        <li>
            <a href="https://github.com/goManual/goManual/issues" target="blank" class="issues-link">Questions and Issues</a>
        </li>
        

        
        
        <li>
            <a href="https://github.com/goManual/goManual/edit/master/bufio/README.md" target="blank" class="contribute-link">Edit and Contribute</a>
        </li>
        

	

        
        <li class="divider"></li>
        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         简介
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="archive/README.html">
            
                
                    <a href="../archive/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         archive
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="archive/tar.html">
            
                
                    <a href="../archive/tar.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         tar
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.2" data-path="archive/zip.html">
            
                
                    <a href="../archive/zip.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         zip
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter active" data-level="2" data-path="bufio/README.html">
            
                
                    <a href="../bufio/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         bufio
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="builtin/README.html">
            
                
                    <a href="../builtin/README.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         builtin
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Generated using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 80%;min-width: 60%;"></div>
    </div>
    <div class="chapters">
    
        <a href="../index.html" title="简介" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="../archive/README.html" title="archive" class="chapter done new-chapter" data-progress="1" style="left: 20%;"></a>
    
        <a href="../archive/tar.html" title="tar" class="chapter done " data-progress="1.1" style="left: 40%;"></a>
    
        <a href="../archive/zip.html" title="zip" class="chapter done " data-progress="1.2" style="left: 60%;"></a>
    
        <a href="../bufio/README.html" title="bufio" class="chapter done new-chapter" data-progress="2" style="left: 80%;"></a>
    
        <a href="../builtin/README.html" title="builtin" class="chapter  new-chapter" data-progress="3" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_5">
                    
                        <h1 id="package-bufio">Package bufio</h1>
<h3 id="overview">Overview</h3>
<p>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.<br>
bufio包实现缓冲区I/O。它包装一个io.Reader或io.Writer对象，创建其他对象 (Reader or Writer) 也实现了该接口 并为I/O文本提供缓冲和一些帮助。<br>
<br><br></p>
<h3 id="constants">Constants</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">const</span> (
    <span class="hljs-comment">// Maximum size used to buffer a token. The actual maximum token size</span>
    <span class="hljs-comment">// may be smaller as the buffer may need to include, for instance, a newline.</span>
    MaxScanTokenSize =<span class="hljs-number"> 64</span> *<span class="hljs-number"> 1024</span>
)
</code></pre>
<p><br><br></p>
<h3 id="variables">Variables</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">var</span> (
    ErrInvalidUnreadByte = errors.New(<span class="hljs-string">"bufio: invalid use of UnreadByte"</span>)
    ErrInvalidUnreadRune = errors.New(<span class="hljs-string">"bufio: invalid use of UnreadRune"</span>)
    ErrBufferFull        = errors.New(<span class="hljs-string">"bufio: buffer full"</span>)
    ErrNegativeCount     = errors.New(<span class="hljs-string">"bufio: negative count"</span>)
)
</code></pre>
<pre><code class="lang-golang"><span class="hljs-keyword">var</span> (
    ErrTooLong         = errors.New(<span class="hljs-string">"bufio.Scanner: token too long"</span>)
    ErrNegativeAdvance = errors.New(<span class="hljs-string">"bufio.Scanner: SplitFunc returns negative advance count"</span>)
    ErrAdvanceTooFar   = errors.New(<span class="hljs-string">"bufio.Scanner: SplitFunc returns advance count beyond input"</span>)
)
</code></pre>
<p>Errors returned by Scanner.<br>
错误通过Scanner返回.<br>
<br><br></p>
<h3 id="func-scanbytes">func ScanBytes</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanBytes(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanBytes is a split function for a Scanner that returns each byte as a token.<br>
ScanBytes是一个分割函数，返回每个字节作为一个token.<br>
<br><br></p>
<h3 id="func-scanlines">func ScanLines</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanLines(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker.The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline.In regular expression notation, it is <code>\r?\n</code>. The last non-empty line of input will be returned even if it has no newline.<br>
ScanLines是一个分割函数。返回文本的每一行，消除任何行尾标记。返回的行有可能是空的. 行尾标记是可选回车强制性的跟在换行符之后。在正则表达式里,它是 <code>\r?\n</code>.最后的非空输入行将会返回 即使它没有换行符.<br>
<br><br></p>
<h3 id="func-scanrunes">func ScanRunes</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanRunes(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token.The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = &quot;\xef\xbf\xbd&quot;.Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.<br>
ScanRunes是一个分割函数, 返回每个 UTF-8编码rune作为 token.rune返回的顺序相当于从一系列循环遍历输入一个字符串，其中错误的utf8，会转为 U+FFFD= &quot;\xef\xbf\xbd&quot;.因为Scan接口，可能让客户端从错误编码中分辨正确的编码 来替换runes.<br>
<br><br></p>
<h3 id="func-scanwords">func ScanWords</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> ScanWords(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ScanWords is a split function for a Scanner that returns each space-separated word of text , with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.<br>
ScanWords是一个分割函数,返回每个空格分隔的文本的词,会删除两边的空格. 它不会返回空字符串. 空格由unicode.IsSpace定义.<br>
<br><br></p>
<h3 id="type-readwriter">type ReadWriter</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">struct</span> {
        *Reader
        *Writer
  }
</code></pre>
<p>ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.<br>
ReadWriter存储一个Reader 和 Writer 指针，实现了io.ReadWriter.<br>
<br><br></p>
<h3 id="func-newreadwriter">func NewReadWriter</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> NewReadWriter(r *Reader, w *Writer) *ReadWriter
</code></pre>
<p>NewReadWriter allocates a new ReadWriter that dispatches to r and w.<br>
NewReadWriter分配一个新的ReadWriter ,分派r和w.<br>
<br><br></p>
<h3 id="type-reader">type Reader</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// contains filtered or unexported fields</span>
}
</code></pre>
<p>Reader implements buffering for an io.Reader object.<br>
Reader实现io.Reader对象的缓冲。<br>
<br><br></p>
<p>func NewReader</p>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> NewReader(rd io.Reader) *Reader
</code></pre>
<p>NewReader returns a new Reader whose buffer has the default size.<br>
NewReader 返回一个新的有默认缓冲区大小的Reader.<br>
<br><br></p>
<h3 id="func-newreadersize">func NewReaderSize</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> NewReaderSize(rd io.Reader, size <span class="hljs-typename">int</span>) *Reader
</code></pre>
<p>NewReaderSize returns a new Reader whose buffer has at least the specified size . If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.<br>
NewReaderSize返回一个新的最少有指定size大小的Reader，如果参数io.Reader是一个足够大的Reader，它返回底层Reader.<br>
<br><br></p>
<h3 id="func-reader-buffered">func (*Reader) Buffered</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) Buffered() <span class="hljs-typename">int</span>
</code></pre>
<p>Buffered returns the number of bytes that can be read from the current buffer.<br>
Buffered返回当前缓冲区可读的字节数.<br>
<br><br></p>
<h3 id="func-reader-peek">func (*Reader) Peek</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) Peek(n <span class="hljs-typename">int</span>) ([]<span class="hljs-typename">byte</span>, error)
</code></pre>
<p>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call.If Peek returns fewer than n bytes, it also returns an error explaining why the read is short.The error is ErrBufferFull if n is larger than b&#39;s buffer size.<br>
Peek 返回下n个字节 没有推进reader. 该字节直到下一次读取调用之前都是有效的.如果Peek 返回少于n字节,它也会返回错误解释为什么读取短了.如果n大于 b的缓冲区大小,那错误是ErrBufferFull.<br>
<br><br></p>
<h3 id="func-reader-read">func (*Reader) Read</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) Read(p []<span class="hljs-typename">byte</span>) (n <span class="hljs-typename">int</span>, err error)
</code></pre>
<p>Read reads data into p. It returns the number of bytes read into p. It calls Read at most once on the underlying Reader, hence n may be less than len(p). At EOF, the count will be zero and err will be io.EOF.<br>
Read读取数据到P. 返回读取到P的字节数.在底层Reader它最多调用一次Read,因此n 可能少于 len(p).在EOF,统计将是零并且err是io.EOF.<br>
<br><br></p>
<h3 id="unc-reader-readbyte">unc (*Reader) ReadByte</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) ReadByte() (c <span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ReadByte reads and returns a single byte. If no byte is available, returns an error.<br>
ReadByte读取和返回单个字节.如果没有可用字节,返回错误.<br>
<br><br></p>
<h3 id="func-reader-readbytes">func (*Reader) ReadBytes</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadBytes(delim <span class="hljs-typename">byte</span>) (line []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.<br>
ReadBytes读取输入的字节，直到第一次遇到delim，返回包含数据和那个分隔符的切片. 如果ReadBytes在发现分隔符之前出现错误，它返回错误之前读取的数据和错误本身(错误经常是io.EOF). ReadBytes只有在数据没有遇到分隔符但却已经读到结束的时候会返回err!=nil。对于简单的运用，Scanner 可能更适合.<br>
<br><br></p>
<h3 id="func-reader-readline">func (*Reader) ReadLine</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadLine() (line []<span class="hljs-typename">byte</span>, isPrefix <span class="hljs-typename">bool</span>, err error)
</code></pre>
<p>ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes(&#39;\n&#39;) or ReadString(&#39;\n&#39;) instead or use a Scanner.<br></p>
<p>ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned.<br></p>
<p>The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine.ReadLine either returns a non-nil line or it returns an error, never both.<br></p>
<p>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.<br></p>
<p>ReadLine是一个低级的行读取原语。大部分的调用者应该使用ReadBytes(&#39;\n&#39;)或者 ReadString(&#39;\n&#39;) 替代 或者用Scanner.<br>
ReadLine试图返回单行，不包含结束符字节。如果行对缓冲区来说太长，isPrefix 设置并返回该行的开始处。<br>
其余的行将会在以后的调用返回。isPrefix 在返回完所有的行后，会变成false。返回的缓冲区在下次调用ReadLine之前是有效的。<br>
ReadLine 要嘛返回非空的行要嘛返回错误，不会两个都同时返回.<br>
ReadLine 返回的文本不包含结束符 (&quot;\r\n&quot; or &quot;\n&quot;)。如果输入结束但最后一行没有结束符是不会有任何迹象和错误的. 在ReadLine之后调用UnreadByte  未读的最后一个字节读(可能是一个属于行结束符) 即使该字节不属于ReadLine返回的行。<br></p>
<p>注:原语是指由若干条指令组成的，用于完成一定功能的一个过程。<br>
<br><br></p>
<h3 id="func-reader-readrune">func (*Reader) ReadRune</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) ReadRune() (r <span class="hljs-typename">rune</span>, size <span class="hljs-typename">int</span>, err error)
</code></pre>
<p>ReadRune reads  single UTF-8 encoded Unicode character and returns the rune and its size in bytes.<br>
If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.<br>
ReadRune 读取单个utf8 编码的字符并返回rune和rune 以字节为单位的size.<br>
如果rune编码无效，它会消耗一个字节并 返回大小为1的unicode.ReplacementChar(U+FFFD).<br>
<br><br></p>
<h3 id="func-reader-readslice">func (*Reader) ReadSlice</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadSlice(delim <span class="hljs-typename">byte</span>) (line []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read call. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.<br>
ReadSlice 读取输入直到第一次遇到分隔符delim，返回一个指向缓冲区字节的slice. 在下一次调用读取之前该字节都是有效的. 如果ReadSlice在遇到分隔符之前发生错误，将会返回缓冲区里的所有数据和错误(通常是io.EOF). 如果缓冲区满了，但是还没遇到分隔符就会有 ErrBufferFull的错误. 因为ReadSlice 返回的数据将会在下一个IO操作时被覆盖，所以大部分的客户端应该用 ReadBytes 或 ReadString 替代. ReadSlice 只会在行没有分隔符结束的情况下返回err != nil .<br>
<br><br></p>
<h3 id="func-b-reader-readstring">func (b *Reader) ReadString</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) ReadString(delim <span class="hljs-typename">byte</span>) (line <span class="hljs-typename">string</span>, err error)
</code></pre>
<p>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.<br>
ReadString读取输入直接遇到第一个分隔符。返回包含分隔符的字符串. 如果ReadString在没有发现分隔符就遇到错误，返回到发生错误之前读取的数据和错误. ReadString 只会在行没有分隔符结束的情况下返回err != nil。对于简单的运用，Scanner适合.<br>
<br><br></p>
<h3 id="func-reader-reset">func (*Reader) Reset</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) Reset(r io.Reader)
</code></pre>
<p>Reset discards any buffered data, resets all state, and switches the buffered reader to read from r.<br>
Reset 丢弃任何缓冲区数据,重置所有状态, 切换缓冲区reader 从r读取.<br>
<br><br></p>
<h3 id="func-b-reader-unreadbyte">func (b *Reader) UnreadByte</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) UnreadByte() error
</code></pre>
<p>UnreadByte unreads the last byte. Only the most recently read byte can be unread.<br>
UnreadByte 撤消最后一次读出的字节.有最后读出的字节可以被撤消.<br>
<br><br></p>
<h3 id="func-b-reader-unreadrune">func (b *Reader) UnreadRune</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Reader) UnreadRune() error
</code></pre>
<p>UnreadRune unreads the last rune. If the most recent read operation on the buffer was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.).<br>
撤销最后一次读出的rune.如果最后一次操作不是ReadRune，返回错误。（在这方面，它比UnreadByte严格）.<br>
<br><br></p>
<h3 id="func-reader-writeto">func (*Reader) WriteTo</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> (b *Reader) WriteTo(w io.Writer) (n <span class="hljs-typename">int64</span>, err error)
</code></pre>
<p>WriteTo implements io.WriterTo.<br>
实现io.WriterTo.<br>
<br><br></p>
<h3 id="type-scanner">type Scanner</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">type</span> Scanner <span class="hljs-keyword">struct</span> {
        <span class="hljs-comment">// contains filtered or unexported fields</span>
  }
</code></pre>
<p>  Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text.
      Scanner提供一个更方便的接口读取数据，如例如读取一个多行文本.</p>
<p>  Successive calls to the Scan method will step through the &#39;tokens&#39; of a file, skipping the bytes between the tokens.
  连续调用Scan方法将单步调试文件的&#39;tokens&#39;,跳过tokens之间的字节.</p>
<p>  The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped.
      token的规范由SplitFunc类型的分割函数定义; 默认的分割函数</p>
<p>  Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.
      分割函数在这个包是一个文件的行，字节，UTF8字节和间隔符。客户端可以自定义函数来替代分割函数。</p>
<p>  Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token.
      搜索在遇到结束符、第一个I/O错误、或者token大于缓冲区的大小。当一个搜索结束，读取者也许会离最后一个token任意远。</p>
<p>  Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead.
      程序在必须更多的控制错误处理或太大的tokens，或者连续的搜索，应该用 bufio.Reader代替</p>
<p><br><br></p>
<h3 id="example-custom">Example (Custom)</h3>
<p>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.<br>
Code:<br></p>
<pre><code class="lang-golang"><span class="hljs-comment">// An artificial input source.</span>
<span class="hljs-keyword">const</span> input = <span class="hljs-string">"1234 5678 1234567901234567890"</span>
scanner := bufio.NewScanner(strings.NewReader(input))
<span class="hljs-comment">// Create a custom split function by wrapping the existing ScanWords function.</span>
split := <span class="hljs-keyword">func</span>(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error) {
    advance, token, err = bufio.ScanWords(data, atEOF)
    <span class="hljs-keyword">if</span> err == <span class="hljs-constant">nil</span> &amp;&amp; token != <span class="hljs-constant">nil</span> {
        _, err = strconv.ParseInt(<span class="hljs-typename">string</span>(token),<span class="hljs-number"> 10</span>,<span class="hljs-number"> 32</span>)
    }
    <span class="hljs-keyword">return</span>
}
<span class="hljs-comment">// Set the split function for the scanning operation.</span>
scanner.Split(split)
<span class="hljs-comment">// Validate the input</span>
<span class="hljs-keyword">for</span> scanner.Scan() {
    fmt.Printf(<span class="hljs-string">"%s\n"</span>, scanner.Text())
}

<span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-constant">nil</span> {
    fmt.Printf(<span class="hljs-string">"Invalid input: %s"</span>, err)
}
</code></pre>
<p><br>
Output:
<br></p>
<pre><code class="lang-golang"><span class="hljs-number">1234</span><span class="hljs-number">
5678</span>
Invalid input: strconv.ParseInt: parsing <span class="hljs-string">"1234567901234567890"</span>: value out of <span class="hljs-keyword">range</span>
</code></pre>
<pre><code class="lang-golang">Example (Lines)
The simplest use of a Scanner, to read standard input as a set of lines.

Code:

scanner := bufio.NewScanner(os.Stdin)
<span class="hljs-keyword">for</span> scanner.Scan() {
    fmt.Println(scanner.Text()) <span class="hljs-comment">// Println will add back the final '\n'</span>
}
<span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-constant">nil</span> {
    fmt.Fprintln(os.Stderr, <span class="hljs-string">"reading standard input:"</span>, err)
}
</code></pre>
<p><br><br></p>
<p>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.<br>
Code:<br></p>
<pre><code class="lang-golang"><span class="hljs-comment">// An artificial input source.</span>
<span class="hljs-keyword">const</span> input = <span class="hljs-string">"Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n"</span>
scanner := bufio.NewScanner(strings.NewReader(input))
<span class="hljs-comment">// Set the split function for the scanning operation.</span>
scanner.Split(bufio.ScanWords)
<span class="hljs-comment">// Count the words.</span>
count :=<span class="hljs-number"> 0</span>
<span class="hljs-keyword">for</span> scanner.Scan() {
    count++
}
<span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-constant">nil</span> {
    fmt.Fprintln(os.Stderr, <span class="hljs-string">"reading input:"</span>, err)
}
fmt.Printf(<span class="hljs-string">"%d\n"</span>, count)
</code></pre>
<p><br>
Output:
<br></p>
<pre><code class="lang-golang"><span class="hljs-number">15</span>
</code></pre>
<p><br><br></p>
<h3 id="func-newscanner">func NewScanner</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> NewScanner(r io.Reader) *Scanner
</code></pre>
<p>NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines<br>
NewScanner 从r返回一个新的Scanner。分割函数默认是ScanLines<br>
<br><br></p>
<h3 id="func-scanner-bytes">func (*Scanner) Bytes</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Bytes() []<span class="hljs-typename">byte</span>
</code></pre>
<p>Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.<br>
Bytes 将最后一次调用Scan扫描出的切片返回。调用Scan 会覆盖 底层数组指向的数据。<br>
<br><br></p>
<h3 id="func-s-scanner-err">func (s *Scanner) Err</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Err() error
</code></pre>
<p>Err returns the first non-EOF error that was encountered by the Scanner.<br>
Err 返回Scanner遇到第一个非EOF错误.<br>
<br><br></p>
<h3 id="func-s-scanner-scan">func (s *Scanner) Scan</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Scan() <span class="hljs-typename">bool</span>
</code></pre>
<p>Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. <br>
Scan Scanner下一个token， 然后通过Bytes或者Text方法取出。当然搜索停止、搜索到末尾、或遇到错误时返回false。当Scan 返回false。Err 方法将会返回在搜索期间遇到的任何错误，除了io.EOF会返回nil。<br>
<br><br></p>
<h3 id="func-scanner-split">func (*Scanner) Split</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Split(split SplitFunc)
</code></pre>
<p>Split sets the split function for the Scanner. If called, it must be called before Scan. The default split function is ScanLines.<br>
Split 设置Scanner的分割函数，如果有调用，必须在Scan之前调用，默认的分割函数是ScanLines.<br>
<br><br></p>
<h3 id="func-scanner-text">func (*Scanner) Text</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (s *Scanner) Text() <span class="hljs-typename">string</span>
</code></pre>
<p>Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.<br>
Text 返回在调用Scan重新分配字符串的时候,最后一次扫描的字符串.<br>
<br><br></p>
<h3 id="type-splitfunc">type SplitFunc</h3>
<pre><code class="lang-golang">  <span class="hljs-keyword">type</span> SplitFunc <span class="hljs-keyword">func</span>(data []<span class="hljs-typename">byte</span>, atEOF <span class="hljs-typename">bool</span>) (advance <span class="hljs-typename">int</span>, token []<span class="hljs-typename">byte</span>, err error)
</code></pre>
<p>SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, plus an error, if any. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, SplitFunc can return (0, nil) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input.<br></p>
<p>If the returned error is non-nil, scanning stops and the error is returned to the client.<br></p>
<p>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.<br></p>
<p>SplitFunc是分割函数用于标记输入。参数初始化未处理剩余的子字符串数据 和一个flag, atEOF, 报告Reader是否已经没有数据. 返回值是读取到下一个标示的字节数，如果有错误的话加上一个错误。 如果数据没有一个完整的标示，例如扫描行的时候没有换行符，SplitFunc 返回 (0, nil) 来通知Scanner  读取更多数据到slice 并 在一次以一个更大的slice尝试.<br></p>
<p>如果返回的错误不是nil，扫描终止，错误返回给客户端。<br></p>
<p>除非atEOF 参数的值是true，否则函数不会以一个空数据的切片调用。如果atEOF 是true，data参数有可能是非空的，通常是未处理的数据.<br></p>
<h3 id="type-writer">type Writer</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">struct</span> {
        <span class="hljs-comment">// contains filtered or unexported fields</span>
}
</code></pre>
<p>Writer implements buffering for an io.Writer object. If an error occurs writing to a Writer, no more data will be accepted and all subsequent writes will return the error.<br>
Writer实现 io.Writer 缓冲区对象。如果遇到错误，就不会再接收数据并所有子请求都返回错误。<br>
<br>
▹ Example<br></p>
<pre><code class="lang-golang"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"bufio"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"os"</span>
)

<span class="hljs-keyword">func</span> main() {
    w := bufio.NewWriter(os.Stdout)
    fmt.Fprint(w, <span class="hljs-string">"Hello, "</span>)
    fmt.Fprint(w, <span class="hljs-string">"world!"</span>)
    w.Flush() <span class="hljs-comment">// Don't forget to flush!</span>
}
</code></pre>
<h3 id="func-newwriter">func NewWriter</h3>
<pre><code class="lang-golang"><span class="hljs-keyword">func</span> NewWriter(wr io.Writer) *Writer
</code></pre>
<p>NewWriter returns a new Writer whose buffer has the default size.<br>
NewWriter 返回一个有默认大小的缓冲区Writer.<br>
<br><br></p>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> NewWriterSize(wr io.Writer, size <span class="hljs-typename">int</span>) *Writer
    NewWriterSize returns a <span class="hljs-built_in">new</span> Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.
    NewWriterSize 返回一个至少有指定大小的缓冲区新对象。如果参数io.Writer是一个足够大小的Writer，会返回Writer。 （注：就是说谁大返回谁）
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Available() <span class="hljs-typename">int</span>
    Available returns how many bytes are unused in the buffer.
    Available 返回缓冲区还有多少字节没有被使用。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Buffered() <span class="hljs-typename">int</span>
    Buffered returns the number of bytes that have been written into the current buffer.
    Buffered 返回已经被写入的缓冲区的字节数。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Flush() error
    Flush writes any buffered data to the underlying io.Writer.
    Flush 把缓冲区数据写入到底层io.Writer
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) ReadFrom(r io.Reader) (n <span class="hljs-typename">int64</span>, err error)
    ReadFrom implements io.ReaderFrom.
    ReadFrom 实现 io.ReaderFrom.
</code></pre>
<pre><code class="lang-golang">    <span class="hljs-keyword">func</span> (b *Writer) Reset(w io.Writer)
        Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.
        丢弃缓冲区里未刷新的数据，清除所有错误，重置b写入到w
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) Write(p []<span class="hljs-typename">byte</span>) (nn <span class="hljs-typename">int</span>, err error)
    Write writes the contents of p into the buffer. It returns the number of bytes written. If nn &lt; <span class="hljs-built_in">len</span>(p), it also returns an error explaining why the write is short.
    Write将p的内容写入缓冲区。返回写入字节数。如果返回的字节数nn 小于 p的长度，它也会返回一个错误说明为什么写入短了。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) WriteByte(c <span class="hljs-typename">byte</span>) error
    WriteByte writes a single <span class="hljs-typename">byte</span>.
    WriteByte写入单字节
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) WriteRune(r <span class="hljs-typename">rune</span>) (size <span class="hljs-typename">int</span>, err error)
    WriteRune writes a single Unicode code point, returning the number of bytes written and any error.
    WriteRune写入单个Unicode编码字符。返回写入的字节数并返回遇到的错误。
</code></pre>
<pre><code class="lang-golang">  <span class="hljs-keyword">func</span> (b *Writer) WriteString(s <span class="hljs-typename">string</span>) (<span class="hljs-typename">int</span>, error)
    WriteString writes a <span class="hljs-typename">string</span>. It returns the number of bytes written. If the count is less than <span class="hljs-built_in">len</span>(s), it also returns an error explaining why the write is short.
    WriteString 写入一个字符串。返回写入的字节数。如果字节数少于s参数的长度，它也会返回一个错误说明为什么写入短了。
</code></pre>

                    
                    </section>
                
                </div>
            </div>
        </div>

<!--
        
        <a href="../archive/zip.html" class="navigation navigation-prev " aria-label="Previous page: zip"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../builtin/README.html" class="navigation navigation-next " aria-label="Next page: builtin"><i class="fa fa-angle-right"></i></a>
        
-->

    </div>
</div>

        
<script src="../gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
<script src="../gitbook/app.js"></script>

<script src="../gitbook/MathJax.js"></script>
<!--
    
    <script src="https://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    
-->


<script>
require(["gitbook"], function(gitbook) {
    var config = {};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
